{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _promise = require('babel-runtime/core-js/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _createDeferred = require('./createDeferred');\n\nvar _createDeferred2 = _interopRequireDefault(_createDeferred);\n\nvar _retry = require('./retry');\n\nvar _retry2 = _interopRequireDefault(_retry);\n\nvar _sleep = require('./sleep');\n\nvar _sleep2 = _interopRequireDefault(_sleep);\n\nvar _spinWaitUntil = require('./spinWaitUntil');\n\nvar _spinWaitUntil2 = _interopRequireDefault(_spinWaitUntil);\n\nvar _timeout = require('./timeout');\n\nvar _timeout2 = _interopRequireDefault(_timeout);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction createNativeUtterance(utteranceLike, ponyfill) {\n  var speechSynthesis = ponyfill.speechSynthesis,\n      SpeechSynthesisUtterance = ponyfill.SpeechSynthesisUtterance;\n  var lang = utteranceLike.lang,\n      onBoundary = utteranceLike.onBoundary,\n      _utteranceLike$pitch = utteranceLike.pitch,\n      pitch = _utteranceLike$pitch === undefined ? 1 : _utteranceLike$pitch,\n      _utteranceLike$rate = utteranceLike.rate,\n      rate = _utteranceLike$rate === undefined ? 1 : _utteranceLike$rate,\n      text = utteranceLike.text,\n      voice = utteranceLike.voice,\n      _utteranceLike$volume = utteranceLike.volume,\n      volume = _utteranceLike$volume === undefined ? 1 : _utteranceLike$volume;\n  var utterance = new SpeechSynthesisUtterance(text);\n  var targetVoice = void 0;\n\n  if (typeof voice === 'function') {\n    targetVoice = voice.call(speechSynthesis, speechSynthesis.getVoices());\n  } else {\n    var _ref = voice || {},\n        voiceURI = _ref.voiceURI;\n\n    targetVoice = voiceURI && [].find.call([].slice.call(speechSynthesis.getVoices()), function (v) {\n      return v.voiceURI === voiceURI;\n    });\n  } // Edge will mute if \"lang\" is set to \"\"\n\n\n  utterance.lang = lang || '';\n\n  if (utterance.pitch || utterance.pitch === 0) {\n    utterance.pitch = pitch;\n  }\n\n  if (utterance.rate || utterance.rate === 0) {\n    utterance.rate = rate;\n  } // Cognitive Services will error when \"voice\" is set to \"null\"\n  // Edge will error when \"voice\" is set to \"undefined\"\n\n\n  if (targetVoice) {\n    utterance.voice = targetVoice;\n  }\n\n  if (utterance.volume || utterance.volume === 0) {\n    utterance.volume = volume;\n  }\n\n  if (utterance.addEventListener) {\n    if (onBoundary) {\n      utterance.addEventListener('boundary', onBoundary);\n    } // Since browser quirks, start/error/end events are emulated for best compatibility\n\n  }\n\n  return utterance;\n}\n\nvar Utterance = function () {\n  function Utterance(utteranceLike) {\n    (0, _classCallCheck3.default)(this, Utterance);\n    this.cancelled = false;\n    this.deferred = (0, _createDeferred2.default)();\n    this.id = utteranceLike.id;\n    this.speaking = false;\n    this.utteranceLike = utteranceLike;\n  }\n\n  (0, _createClass3.default)(Utterance, [{\n    key: 'cancel',\n    value: function cancel() {\n      this.cancelled = true;\n      this.speaking && this.ponyfill.speechSynthesis.cancel();\n      return this.deferred.promise;\n    }\n  }, {\n    key: 'speak',\n    value: function speak(ponyfill) {\n      var _this = this;\n\n      this._speak(ponyfill).then(function () {\n        _this.utteranceLike.onEnd && _this.utteranceLike.onEnd({\n          type: 'end'\n        });\n\n        _this.deferred.resolve();\n      }, function (error) {\n        _this.utteranceLike.onError && _this.utteranceLike.onError({\n          type: 'error',\n          error: error\n        });\n\n        _this.deferred.reject(error);\n      });\n\n      return this.deferred.promise;\n    }\n  }, {\n    key: '_speak',\n    value: function () {\n      var _ref2 = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee2(ponyfill) {\n        var _this2 = this;\n\n        var speechSynthesis, utterance, startDeferred, errorDeferred, endDeferred, endEvent;\n        return _regenerator2.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.cancelled) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error('cancelled');\n\n              case 2:\n                this.ponyfill = ponyfill;\n                speechSynthesis = ponyfill.speechSynthesis;\n                utterance = createNativeUtterance(this.utteranceLike, ponyfill);\n                startDeferred = (0, _createDeferred2.default)();\n                errorDeferred = (0, _createDeferred2.default)();\n                endDeferred = (0, _createDeferred2.default)();\n                utterance.addEventListener('end', endDeferred.resolve);\n                utterance.addEventListener('error', errorDeferred.resolve);\n                utterance.addEventListener('start', startDeferred.resolve); // if (speechSynthesis.speaking) {\n                //   console.warn(`ASSERTION: speechSynthesis.speaking should not be truthy before we call speak`);\n                // }\n                // Chrome quirks:\n                // 1. Speak an utterance\n                // 2. Cancel in the midway\n                // 3. Speak another utterance\n                // Expected: speaking is falsy, then turn to truthy, then receive \"start\" event, and audio played\n                // Actual: speaking is falsy, then turn to truthy (which is wrong), but receive no \"start\" event, and no audio played\n                // Workaround: retry 2 times with a second\n                // Safari quirks:\n                // - Audio doesn't play if the speech is started from a user event\n                // - If no audio is played, the \"start\" event won't fire\n                // For Chrome quirks, we need a custom queue, because we need to definitely know when to expect a \"start\" event.\n                // If we don't have a queue, the \"start\" event could be happening long time later because it's still pending in the queue.\n                // But with the custom queue, the first item might be started from non-user event. That means in Safari, the first item is muted.\n                // And after the first fail, the custom queue will play the second item from a non-user event code path. That means, all subsequent\n                // items are blocked until Safari has the very first item queued from user event.\n                // console.debug(`STARTING: ${ utterance.text }`);\n\n                this.speaking = true;\n                _context2.next = 14;\n                return (0, _retry2.default)((0, _asyncToGenerator3.default)(\n                /*#__PURE__*/\n                _regenerator2.default.mark(function _callee() {\n                  return _regenerator2.default.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          if (!_this2.cancelled) {\n                            _context.next = 2;\n                            break;\n                          }\n\n                          throw new Error('cancelled');\n\n                        case 2:\n                          speechSynthesis.speak(utterance);\n                          _context.prev = 3;\n                          _context.next = 6;\n                          return _promise2.default.race([startDeferred.promise, (0, _timeout2.default)(1000)]);\n\n                        case 6:\n                          _context.next = 12;\n                          break;\n\n                        case 8:\n                          _context.prev = 8;\n                          _context.t0 = _context['catch'](3); // This is required for Chrome quirks.\n                          // Chrome doesn't know it can't start speech, and it just wait there forever.\n                          // We need to cancel it out.\n\n                          speechSynthesis.cancel();\n                          throw _context.t0;\n\n                        case 12:\n                        case 'end':\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee, _this2, [[3, 8]]);\n                })), 2, 0);\n\n              case 14:\n                // console.debug(`STARTED: ${ utterance.text }`);\n                utterance.onStart && utterance.onStart({\n                  type: 'start'\n                });\n                _context2.next = 17;\n                return _promise2.default.race([errorDeferred.promise, endDeferred.promise, (0, _spinWaitUntil2.default)(function () {\n                  return !speechSynthesis.speaking;\n                }).then(function () {\n                  return (0, _sleep2.default)(500);\n                }).then(function () {\n                  return {\n                    type: 'end',\n                    artificial: true\n                  };\n                })]);\n\n              case 17:\n                endEvent = _context2.sent; // if (speechSynthesis.speaking) {\n                //   console.warn(`ASSERTION: speechSynthesis.speaking should not be truthy after speak is stopped`);\n                // }\n                // console.debug(`ENDED: ${ utterance.text }`);\n\n                this.speaking = false;\n\n                if (!(endEvent.type === 'error')) {\n                  _context2.next = 23;\n                  break;\n                }\n\n                throw endEvent.error;\n\n              case 23:\n                if (!this.cancelled) {\n                  _context2.next = 25;\n                  break;\n                }\n\n                throw new Error('cancelled');\n\n              case 25:\n              case 'end':\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _speak(_x) {\n        return _ref2.apply(this, arguments);\n      }\n\n      return _speak;\n    }()\n  }]);\n  return Utterance;\n}();\n\nexports.default = Utterance;","map":null,"metadata":{},"sourceType":"script"}