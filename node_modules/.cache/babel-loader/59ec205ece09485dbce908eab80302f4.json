{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');\n\nvar _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _memoizeOne = require('memoize-one');\n\nvar _memoizeOne2 = _interopRequireDefault(_memoizeOne);\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _Context = require('./Context');\n\nvar _Context2 = _interopRequireDefault(_Context);\n\nvar _Utterance = require('./Utterance');\n\nvar _Utterance2 = _interopRequireDefault(_Utterance);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar SpeechContext = function () {\n  function SpeechContext(ponyfill) {\n    (0, _classCallCheck3.default)(this, SpeechContext);\n    this.queueWithCurrent = [];\n    this.cancel = this.cancel.bind(this);\n    this.cancelAll = this.cancelAll.bind(this);\n    this.speak = this.speak.bind(this);\n    this.setPonyfill(ponyfill);\n  }\n\n  (0, _createClass3.default)(SpeechContext, [{\n    key: 'setPonyfill',\n    value: function setPonyfill(_ref) {\n      var speechSynthesis = _ref.speechSynthesis,\n          SpeechSynthesisUtterance = _ref.SpeechSynthesisUtterance;\n      this.ponyfill = {\n        speechSynthesis: speechSynthesis,\n        SpeechSynthesisUtterance: SpeechSynthesisUtterance\n      };\n    }\n  }, {\n    key: 'cancel',\n    value: function () {\n      var _ref2 = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee(id) {\n        var index;\n        return _regenerator2.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                index = this.queueWithCurrent.findIndex(function (utterance) {\n                  return utterance.id === id;\n                });\n\n                if (!~index) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt('return', this.queueWithCurrent[index].cancel());\n\n              case 3:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function cancel(_x) {\n        return _ref2.apply(this, arguments);\n      }\n\n      return cancel;\n    }()\n  }, {\n    key: 'cancelAll',\n    value: function () {\n      var _ref3 = (0, _asyncToGenerator3.default)(\n      /*#__PURE__*/\n      _regenerator2.default.mark(function _callee2() {\n        return _regenerator2.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n              case 'end':\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function cancelAll() {\n        return _ref3.apply(this, arguments);\n      }\n\n      return cancelAll;\n    }()\n  }, {\n    key: 'speak',\n    value: function speak(utteranceLike) {\n      // console.debug(`QUEUED: ${ utteranceLike.text }`);\n      if (utteranceLike.id && this.queueWithCurrent.find(function (_ref4) {\n        var id = _ref4.id;\n        return id === utteranceLike.id;\n      })) {\n        // Do not queue duplicated speak with same unique ID\n        // console.debug('NOT QUEUEING DUPE');\n        return;\n      }\n\n      var utterance = new _Utterance2.default(utteranceLike);\n      this.queueWithCurrent = [].concat((0, _toConsumableArray3.default)(this.queueWithCurrent), [utterance]);\n\n      if (this.queueWithCurrent.length === 1) {\n        this._next();\n      }\n\n      return utterance.deferred.promise;\n    }\n  }, {\n    key: '_next',\n    value: function _next() {\n      var _this = this;\n\n      var utterance = this.queueWithCurrent[0];\n\n      if (!utterance) {\n        return;\n      }\n\n      var id = utterance.id;\n      var promise = utterance.speak(this.ponyfill);\n      promise.then(function () {\n        _this.queueWithCurrent = _this.queueWithCurrent.filter(function (utterance) {\n          return utterance.id !== id;\n        });\n\n        _this._next();\n      }, function () {\n        // TODO: If the error is due to Safari restriction on user touch\n        //       The next loop on the next audio will also fail because it was not queued with a user touch\n        _this.queueWithCurrent = _this.queueWithCurrent.filter(function (utterance) {\n          return utterance.id !== id;\n        });\n\n        _this._next();\n      });\n    }\n  }]);\n  return SpeechContext;\n}();\n\nvar Composer = function (_React$Component) {\n  (0, _inherits3.default)(Composer, _React$Component);\n\n  function Composer(props) {\n    (0, _classCallCheck3.default)(this, Composer);\n\n    var _this2 = (0, _possibleConstructorReturn3.default)(this, (Composer.__proto__ || (0, _getPrototypeOf2.default)(Composer)).call(this, props));\n\n    _this2.handleVoicesChanged = _this2.handleVoicesChanged.bind(_this2);\n    var voices = [];\n\n    if (props.speechSynthesis) {\n      props.speechSynthesis.addEventListener && props.speechSynthesis.addEventListener('voiceschanged', _this2.handleVoicesChanged);\n      voices = props.speechSynthesis.getVoices();\n    }\n\n    _this2.mergeContext = (0, _memoizeOne2.default)(function (_ref5, voices) {\n      var cancel = _ref5.cancel,\n          speak = _ref5.speak;\n      return {\n        cancel: cancel,\n        speak: speak,\n        voices: voices\n      };\n    });\n    _this2.state = {\n      context: new SpeechContext({\n        speechSynthesis: props.speechSynthesis,\n        SpeechSynthesisUtterance: props.speechSynthesisUtterance\n      }),\n      voices: voices\n    };\n    return _this2;\n  }\n\n  (0, _createClass3.default)(Composer, [{\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      var props = this.props;\n      var changed = ['speechSynthesis', 'speechSynthesisUtterance'].some(function (name) {\n        return nextProps[name] !== props[name];\n      });\n\n      if (changed) {\n        if (props.speechSynthesis) {\n          props.speechSynthesis.removeEventListener && props.speechSynthesis.removeEventListener('voiceschanged', this.handleVoicesChanged);\n        }\n\n        this.state.context.setPonyfill({\n          speechSynthesis: nextProps.speechSynthesis,\n          SpeechSynthesisUtterance: nextProps.speechSynthesisUtterance\n        });\n        var nextVoices = [];\n\n        if (nextProps.speechSynthesis) {\n          nextProps.speechSynthesis.addEventListener && nextProps.speechSynthesis.addEventListener('voiceschanged', this.handleVoicesChanged);\n          nextVoices = nextProps.speechSynthesis.getVoices() || [];\n        }\n\n        this.setState(function () {\n          return {\n            voices: nextVoices\n          };\n        });\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var speechSynthesis = this.props.speechSynthesis;\n      speechSynthesis && speechSynthesis.removeEventListener && speechSynthesis.removeEventListener('voiceschanged', this.handleVoicesChanged);\n    }\n  }, {\n    key: 'handleVoicesChanged',\n    value: function handleVoicesChanged(_ref6) {\n      var target = _ref6.target;\n      this.setState(function () {\n        return {\n          voices: target.getVoices()\n        };\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this3 = this;\n\n      var props = this.props,\n          state = this.state;\n      var children = props.children;\n      return _react2.default.createElement(_Context2.default.Consumer, null, function (context) {\n        return context ? typeof children === 'function' ? children(context) : children : _react2.default.createElement(_Context2.default.Provider, {\n          value: _this3.mergeContext(state.context, state.voices)\n        }, typeof children === 'function' ? _react2.default.createElement(_Context2.default.Consumer, null, function (context) {\n          return children(context);\n        }) : children);\n      });\n    }\n  }]);\n  return Composer;\n}(_react2.default.Component);\n\nexports.default = Composer;\nComposer.defaultProps = {\n  speechSynthesis: window.speechSynthesis || window.webkitSpeechSynthesis,\n  speechSynthesisUtterance: window.SpeechSynthesisUtterance || window.webkitSpeechSynthesisUtterance\n};\nComposer.propTypes = {\n  speechSynthesis: _propTypes2.default.any,\n  speechSynthesisUtterance: _propTypes2.default.any\n};","map":null,"metadata":{},"sourceType":"script"}