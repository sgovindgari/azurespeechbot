'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _createDeferred = require('./createDeferred');

var _createDeferred2 = _interopRequireDefault(_createDeferred);

var _retry = require('./retry');

var _retry2 = _interopRequireDefault(_retry);

var _sleep = require('./sleep');

var _sleep2 = _interopRequireDefault(_sleep);

var _spinWaitUntil = require('./spinWaitUntil');

var _spinWaitUntil2 = _interopRequireDefault(_spinWaitUntil);

var _timeout = require('./timeout');

var _timeout2 = _interopRequireDefault(_timeout);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createNativeUtterance(utteranceLike, ponyfill) {
  var speechSynthesis = ponyfill.speechSynthesis,
      SpeechSynthesisUtterance = ponyfill.SpeechSynthesisUtterance;
  var lang = utteranceLike.lang,
      onBoundary = utteranceLike.onBoundary,
      _utteranceLike$pitch = utteranceLike.pitch,
      pitch = _utteranceLike$pitch === undefined ? 1 : _utteranceLike$pitch,
      _utteranceLike$rate = utteranceLike.rate,
      rate = _utteranceLike$rate === undefined ? 1 : _utteranceLike$rate,
      text = utteranceLike.text,
      voice = utteranceLike.voice,
      _utteranceLike$volume = utteranceLike.volume,
      volume = _utteranceLike$volume === undefined ? 1 : _utteranceLike$volume;

  var utterance = new SpeechSynthesisUtterance(text);
  var targetVoice = void 0;

  if (typeof voice === 'function') {
    targetVoice = voice.call(speechSynthesis, speechSynthesis.getVoices());
  } else {
    var _ref = voice || {},
        voiceURI = _ref.voiceURI;

    targetVoice = voiceURI && [].find.call([].slice.call(speechSynthesis.getVoices()), function (v) {
      return v.voiceURI === voiceURI;
    });
  }

  // Edge will mute if "lang" is set to ""
  utterance.lang = lang || '';

  if (utterance.pitch || utterance.pitch === 0) {
    utterance.pitch = pitch;
  }

  if (utterance.rate || utterance.rate === 0) {
    utterance.rate = rate;
  }

  // Cognitive Services will error when "voice" is set to "null"
  // Edge will error when "voice" is set to "undefined"
  if (targetVoice) {
    utterance.voice = targetVoice;
  }

  if (utterance.volume || utterance.volume === 0) {
    utterance.volume = volume;
  }

  if (utterance.addEventListener) {
    if (onBoundary) {
      utterance.addEventListener('boundary', onBoundary);
    }

    // Since browser quirks, start/error/end events are emulated for best compatibility
  }

  return utterance;
}

var Utterance = function () {
  function Utterance(utteranceLike) {
    (0, _classCallCheck3.default)(this, Utterance);

    this.cancelled = false;
    this.deferred = (0, _createDeferred2.default)();
    this.id = utteranceLike.id;
    this.speaking = false;
    this.utteranceLike = utteranceLike;
  }

  (0, _createClass3.default)(Utterance, [{
    key: 'cancel',
    value: function cancel() {
      this.cancelled = true;

      this.speaking && this.ponyfill.speechSynthesis.cancel();

      return this.deferred.promise;
    }
  }, {
    key: 'speak',
    value: function speak(ponyfill) {
      var _this = this;

      this._speak(ponyfill).then(function () {
        _this.utteranceLike.onEnd && _this.utteranceLike.onEnd({ type: 'end' });
        _this.deferred.resolve();
      }, function (error) {
        _this.utteranceLike.onError && _this.utteranceLike.onError({ type: 'error', error: error });
        _this.deferred.reject(error);
      });

      return this.deferred.promise;
    }
  }, {
    key: '_speak',
    value: function () {
      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(ponyfill) {
        var _this2 = this;

        var speechSynthesis, utterance, startDeferred, errorDeferred, endDeferred, endEvent;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this.cancelled) {
                  _context2.next = 2;
                  break;
                }

                throw new Error('cancelled');

              case 2:

                this.ponyfill = ponyfill;

                speechSynthesis = ponyfill.speechSynthesis;
                utterance = createNativeUtterance(this.utteranceLike, ponyfill);
                startDeferred = (0, _createDeferred2.default)();
                errorDeferred = (0, _createDeferred2.default)();
                endDeferred = (0, _createDeferred2.default)();


                utterance.addEventListener('end', endDeferred.resolve);
                utterance.addEventListener('error', errorDeferred.resolve);
                utterance.addEventListener('start', startDeferred.resolve);

                // if (speechSynthesis.speaking) {
                //   console.warn(`ASSERTION: speechSynthesis.speaking should not be truthy before we call speak`);
                // }

                // Chrome quirks:
                // 1. Speak an utterance
                // 2. Cancel in the midway
                // 3. Speak another utterance
                // Expected: speaking is falsy, then turn to truthy, then receive "start" event, and audio played
                // Actual: speaking is falsy, then turn to truthy (which is wrong), but receive no "start" event, and no audio played
                // Workaround: retry 2 times with a second

                // Safari quirks:
                // - Audio doesn't play if the speech is started from a user event
                // - If no audio is played, the "start" event won't fire

                // For Chrome quirks, we need a custom queue, because we need to definitely know when to expect a "start" event.
                // If we don't have a queue, the "start" event could be happening long time later because it's still pending in the queue.

                // But with the custom queue, the first item might be started from non-user event. That means in Safari, the first item is muted.
                // And after the first fail, the custom queue will play the second item from a non-user event code path. That means, all subsequent
                // items are blocked until Safari has the very first item queued from user event.

                // console.debug(`STARTING: ${ utterance.text }`);

                this.speaking = true;

                _context2.next = 14;
                return (0, _retry2.default)((0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                  return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          if (!_this2.cancelled) {
                            _context.next = 2;
                            break;
                          }

                          throw new Error('cancelled');

                        case 2:

                          speechSynthesis.speak(utterance);

                          _context.prev = 3;
                          _context.next = 6;
                          return _promise2.default.race([startDeferred.promise, (0, _timeout2.default)(1000)]);

                        case 6:
                          _context.next = 12;
                          break;

                        case 8:
                          _context.prev = 8;
                          _context.t0 = _context['catch'](3);

                          // This is required for Chrome quirks.
                          // Chrome doesn't know it can't start speech, and it just wait there forever.
                          // We need to cancel it out.
                          speechSynthesis.cancel();

                          throw _context.t0;

                        case 12:
                        case 'end':
                          return _context.stop();
                      }
                    }
                  }, _callee, _this2, [[3, 8]]);
                })), 2, 0);

              case 14:

                // console.debug(`STARTED: ${ utterance.text }`);

                utterance.onStart && utterance.onStart({ type: 'start' });

                _context2.next = 17;
                return _promise2.default.race([errorDeferred.promise, endDeferred.promise, (0, _spinWaitUntil2.default)(function () {
                  return !speechSynthesis.speaking;
                }).then(function () {
                  return (0, _sleep2.default)(500);
                }).then(function () {
                  return { type: 'end', artificial: true };
                })]);

              case 17:
                endEvent = _context2.sent;


                // if (speechSynthesis.speaking) {
                //   console.warn(`ASSERTION: speechSynthesis.speaking should not be truthy after speak is stopped`);
                // }

                // console.debug(`ENDED: ${ utterance.text }`);

                this.speaking = false;

                if (!(endEvent.type === 'error')) {
                  _context2.next = 23;
                  break;
                }

                throw endEvent.error;

              case 23:
                if (!this.cancelled) {
                  _context2.next = 25;
                  break;
                }

                throw new Error('cancelled');

              case 25:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _speak(_x) {
        return _ref2.apply(this, arguments);
      }

      return _speak;
    }()
  }]);
  return Utterance;
}();

exports.default = Utterance;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9VdHRlcmFuY2UuanMiXSwibmFtZXMiOlsiY3JlYXRlTmF0aXZlVXR0ZXJhbmNlIiwidXR0ZXJhbmNlTGlrZSIsInBvbnlmaWxsIiwic3BlZWNoU3ludGhlc2lzIiwiU3BlZWNoU3ludGhlc2lzVXR0ZXJhbmNlIiwibGFuZyIsIm9uQm91bmRhcnkiLCJwaXRjaCIsInJhdGUiLCJ0ZXh0Iiwidm9pY2UiLCJ2b2x1bWUiLCJ1dHRlcmFuY2UiLCJ0YXJnZXRWb2ljZSIsImNhbGwiLCJnZXRWb2ljZXMiLCJ2b2ljZVVSSSIsImZpbmQiLCJzbGljZSIsInYiLCJhZGRFdmVudExpc3RlbmVyIiwiVXR0ZXJhbmNlIiwiY2FuY2VsbGVkIiwiZGVmZXJyZWQiLCJpZCIsInNwZWFraW5nIiwiY2FuY2VsIiwicHJvbWlzZSIsIl9zcGVhayIsInRoZW4iLCJvbkVuZCIsInR5cGUiLCJyZXNvbHZlIiwib25FcnJvciIsImVycm9yIiwicmVqZWN0IiwiRXJyb3IiLCJzdGFydERlZmVycmVkIiwiZXJyb3JEZWZlcnJlZCIsImVuZERlZmVycmVkIiwic3BlYWsiLCJyYWNlIiwib25TdGFydCIsImFydGlmaWNpYWwiLCJlbmRFdmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQSxTQUFTQSxxQkFBVCxDQUErQkMsYUFBL0IsRUFBOENDLFFBQTlDLEVBQXdEO0FBQUEsTUFDOUNDLGVBRDhDLEdBQ0FELFFBREEsQ0FDOUNDLGVBRDhDO0FBQUEsTUFDN0JDLHdCQUQ2QixHQUNBRixRQURBLENBQzdCRSx3QkFENkI7QUFBQSxNQUdwREMsSUFIb0QsR0FVbERKLGFBVmtELENBR3BESSxJQUhvRDtBQUFBLE1BSXBEQyxVQUpvRCxHQVVsREwsYUFWa0QsQ0FJcERLLFVBSm9EO0FBQUEsNkJBVWxETCxhQVZrRCxDQUtwRE0sS0FMb0Q7QUFBQSxNQUtwREEsS0FMb0Qs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QUE7O0FBQUE7QUFBQTtBQUFBOztBQWFSO0FBQ0E7QUFDQTtBQUNBeEIsMENBQWdCdUIsTUFBaEI7O0FBaEJROztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUFOLElBb0JILENBcEJHLEVBb0JBLENBcEJBLEM7Ozs7QUFzQk47O0FBRUFkLDBCQUFVOEIsT0FBVixJQUFxQjlCLFVBQVU4QixPQUFWLENBQWtCLEVBQUVYLE1BQU0sT0FBUixFQUFsQixDQUFyQjs7O3VCQUV1QixrQkFBUVUsSUFBUixDQUFhLENBQ2xDSCxjQUFjWCxPQURvQixFQUVsQ1ksWUFBWVosT0FGc0IsRUFHbEMsNkJBQWM7QUFBQSx5QkFBTSxDQUFDeEIsZ0JBQWdCc0IsUUFBdkI7QUFBQSxpQkFBZCxFQUErQ0ksSUFBL0MsQ0FBb0Q7QUFBQSx5QkFBTSxxQkFBTSxHQUFOLENBQU47QUFBQSxpQkFBcEQsRUFBc0VBLElBQXRFLENBQTJFO0FBQUEseUJBQU8sRUFBRUUsTUFBTSxLQUFSLEVBQWVZLFlBQVksSUFBM0IsRUFBUDtBQUFBLGlCQUEzRSxDQUhrQyxDQUFiLEM7OztBQUFqQkMsd0I7OztBQU1OO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBS25CLFFBQUwsR0FBZ0IsS0FBaEI7O3NCQUVJbUIsU0FBU2IsSUFBVCxLQUFrQixPOzs7OztzQkFDZGEsU0FBU1YsSzs7O3FCQUNOLEtBQUtaLFM7Ozs7O3NCQUNSLElBQUljLEtBQUosQ0FBVSxXQUFWLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tCQXJIU2YsUyIsImZpbGUiOiJVdHRlcmFuY2UuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlRGVmZXJyZWQgZnJvbSAnLi9jcmVhdGVEZWZlcnJlZCc7XG5pbXBvcnQgcmV0cnkgZnJvbSAnLi9yZXRyeSc7XG5pbXBvcnQgc2xlZXAgZnJvbSAnLi9zbGVlcCc7XG5pbXBvcnQgc3BpbldhaXRVbnRpbCBmcm9tICcuL3NwaW5XYWl0VW50aWwnO1xuaW1wb3J0IHRpbWVvdXQgZnJvbSAnLi90aW1lb3V0JztcblxuZnVuY3Rpb24gY3JlYXRlTmF0aXZlVXR0ZXJhbmNlKHV0dGVyYW5jZUxpa2UsIHBvbnlmaWxsKSB7XG4gIGNvbnN0IHsgc3BlZWNoU3ludGhlc2lzLCBTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2UgfSA9IHBvbnlmaWxsO1xuICBjb25zdCB7XG4gICAgbGFuZyxcbiAgICBvbkJvdW5kYXJ5LFxuICAgIHBpdGNoID0gMSxcbiAgICByYXRlID0gMSxcbiAgICB0ZXh0LFxuICAgIHZvaWNlLFxuICAgIHZvbHVtZSA9IDFcbiAgfSA9IHV0dGVyYW5jZUxpa2U7XG4gIGNvbnN0IHV0dGVyYW5jZSA9IG5ldyBTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2UodGV4dCk7XG4gIGxldCB0YXJnZXRWb2ljZTtcblxuICBpZiAodHlwZW9mIHZvaWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGFyZ2V0Vm9pY2UgPSB2b2ljZS5jYWxsKHNwZWVjaFN5bnRoZXNpcywgc3BlZWNoU3ludGhlc2lzLmdldFZvaWNlcygpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7IHZvaWNlVVJJIH0gPSB2b2ljZSB8fCB7fTtcblxuICAgIHRhcmdldFZvaWNlID0gdm9pY2VVUkkgJiYgW10uZmluZC5jYWxsKFtdLnNsaWNlLmNhbGwoc3BlZWNoU3ludGhlc2lzLmdldFZvaWNlcygpKSwgdiA9PiB2LnZvaWNlVVJJID09PSB2b2ljZVVSSSk7XG4gIH1cblxuICAvLyBFZGdlIHdpbGwgbXV0ZSBpZiBcImxhbmdcIiBpcyBzZXQgdG8gXCJcIlxuICB1dHRlcmFuY2UubGFuZyA9IGxhbmcgfHwgJyc7XG5cbiAgaWYgKHV0dGVyYW5jZS5waXRjaCB8fCB1dHRlcmFuY2UucGl0Y2ggPT09IDApIHtcbiAgICB1dHRlcmFuY2UucGl0Y2ggPSBwaXRjaDtcbiAgfVxuXG4gIGlmICh1dHRlcmFuY2UucmF0ZSB8fCB1dHRlcmFuY2UucmF0ZSA9PT0gMCkge1xuICAgIHV0dGVyYW5jZS5yYXRlID0gcmF0ZTtcbiAgfVxuXG4gIC8vIENvZ25pdGl2ZSBTZXJ2aWNlcyB3aWxsIGVycm9yIHdoZW4gXCJ2b2ljZVwiIGlzIHNldCB0byBcIm51bGxcIlxuICAvLyBFZGdlIHdpbGwgZXJyb3Igd2hlbiBcInZvaWNlXCIgaXMgc2V0IHRvIFwidW5kZWZpbmVkXCJcbiAgaWYgKHRhcmdldFZvaWNlKSB7XG4gICAgdXR0ZXJhbmNlLnZvaWNlID0gdGFyZ2V0Vm9pY2U7XG4gIH1cblxuICBpZiAodXR0ZXJhbmNlLnZvbHVtZSB8fCB1dHRlcmFuY2Uudm9sdW1lID09PSAwKSB7XG4gICAgdXR0ZXJhbmNlLnZvbHVtZSA9IHZvbHVtZTtcbiAgfVxuXG4gIGlmICh1dHRlcmFuY2UuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGlmIChvbkJvdW5kYXJ5KSB7XG4gICAgICB1dHRlcmFuY2UuYWRkRXZlbnRMaXN0ZW5lcignYm91bmRhcnknLCBvbkJvdW5kYXJ5KTtcbiAgICB9XG5cbiAgICAvLyBTaW5jZSBicm93c2VyIHF1aXJrcywgc3RhcnQvZXJyb3IvZW5kIGV2ZW50cyBhcmUgZW11bGF0ZWQgZm9yIGJlc3QgY29tcGF0aWJpbGl0eVxuICB9XG5cbiAgcmV0dXJuIHV0dGVyYW5jZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXR0ZXJhbmNlIHtcbiAgY29uc3RydWN0b3IodXR0ZXJhbmNlTGlrZSkge1xuICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5kZWZlcnJlZCA9IGNyZWF0ZURlZmVycmVkKCk7XG4gICAgdGhpcy5pZCA9IHV0dGVyYW5jZUxpa2UuaWQ7XG4gICAgdGhpcy5zcGVha2luZyA9IGZhbHNlO1xuICAgIHRoaXMudXR0ZXJhbmNlTGlrZSA9IHV0dGVyYW5jZUxpa2U7XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuXG4gICAgdGhpcy5zcGVha2luZyAmJiB0aGlzLnBvbnlmaWxsLnNwZWVjaFN5bnRoZXNpcy5jYW5jZWwoKTtcblxuICAgIHJldHVybiB0aGlzLmRlZmVycmVkLnByb21pc2U7XG4gIH1cblxuICBzcGVhayhwb255ZmlsbCkge1xuICAgIHRoaXMuX3NwZWFrKHBvbnlmaWxsKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMudXR0ZXJhbmNlTGlrZS5vbkVuZCAmJiB0aGlzLnV0dGVyYW5jZUxpa2Uub25FbmQoeyB0eXBlOiAnZW5kJyB9KTtcbiAgICAgIHRoaXMuZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgIH0sIGVycm9yID0+IHtcbiAgICAgIHRoaXMudXR0ZXJhbmNlTGlrZS5vbkVycm9yICYmIHRoaXMudXR0ZXJhbmNlTGlrZS5vbkVycm9yKHsgdHlwZTogJ2Vycm9yJywgZXJyb3IgfSk7XG4gICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5kZWZlcnJlZC5wcm9taXNlO1xuICB9XG5cbiAgYXN5bmMgX3NwZWFrKHBvbnlmaWxsKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbmNlbGxlZCcpO1xuICAgIH1cblxuICAgIHRoaXMucG9ueWZpbGwgPSBwb255ZmlsbDtcblxuICAgIGNvbnN0IHsgc3BlZWNoU3ludGhlc2lzIH0gPSBwb255ZmlsbDtcblxuICAgIGNvbnN0IHV0dGVyYW5jZSA9IGNyZWF0ZU5hdGl2ZVV0dGVyYW5jZSh0aGlzLnV0dGVyYW5jZUxpa2UsIHBvbnlmaWxsKTtcbiAgICBjb25zdCBzdGFydERlZmVycmVkID0gY3JlYXRlRGVmZXJyZWQoKTtcbiAgICBjb25zdCBlcnJvckRlZmVycmVkID0gY3JlYXRlRGVmZXJyZWQoKTtcbiAgICBjb25zdCBlbmREZWZlcnJlZCA9IGNyZWF0ZURlZmVycmVkKCk7XG5cbiAgICB1dHRlcmFuY2UuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgZW5kRGVmZXJyZWQucmVzb2x2ZSk7XG4gICAgdXR0ZXJhbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JEZWZlcnJlZC5yZXNvbHZlKTtcbiAgICB1dHRlcmFuY2UuYWRkRXZlbnRMaXN0ZW5lcignc3RhcnQnLCBzdGFydERlZmVycmVkLnJlc29sdmUpO1xuXG4gICAgLy8gaWYgKHNwZWVjaFN5bnRoZXNpcy5zcGVha2luZykge1xuICAgIC8vICAgY29uc29sZS53YXJuKGBBU1NFUlRJT046IHNwZWVjaFN5bnRoZXNpcy5zcGVha2luZyBzaG91bGQgbm90IGJlIHRydXRoeSBiZWZvcmUgd2UgY2FsbCBzcGVha2ApO1xuICAgIC8vIH1cblxuICAgIC8vIENocm9tZSBxdWlya3M6XG4gICAgLy8gMS4gU3BlYWsgYW4gdXR0ZXJhbmNlXG4gICAgLy8gMi4gQ2FuY2VsIGluIHRoZSBtaWR3YXlcbiAgICAvLyAzLiBTcGVhayBhbm90aGVyIHV0dGVyYW5jZVxuICAgIC8vIEV4cGVjdGVkOiBzcGVha2luZyBpcyBmYWxzeSwgdGhlbiB0dXJuIHRvIHRydXRoeSwgdGhlbiByZWNlaXZlIFwic3RhcnRcIiBldmVudCwgYW5kIGF1ZGlvIHBsYXllZFxuICAgIC8vIEFjdHVhbDogc3BlYWtpbmcgaXMgZmFsc3ksIHRoZW4gdHVybiB0byB0cnV0aHkgKHdoaWNoIGlzIHdyb25nKSwgYnV0IHJlY2VpdmUgbm8gXCJzdGFydFwiIGV2ZW50LCBhbmQgbm8gYXVkaW8gcGxheWVkXG4gICAgLy8gV29ya2Fyb3VuZDogcmV0cnkgMiB0aW1lcyB3aXRoIGEgc2Vjb25kXG5cbiAgICAvLyBTYWZhcmkgcXVpcmtzOlxuICAgIC8vIC0gQXVkaW8gZG9lc24ndCBwbGF5IGlmIHRoZSBzcGVlY2ggaXMgc3RhcnRlZCBmcm9tIGEgdXNlciBldmVudFxuICAgIC8vIC0gSWYgbm8gYXVkaW8gaXMgcGxheWVkLCB0aGUgXCJzdGFydFwiIGV2ZW50IHdvbid0IGZpcmVcblxuICAgIC8vIEZvciBDaHJvbWUgcXVpcmtzLCB3ZSBuZWVkIGEgY3VzdG9tIHF1ZXVlLCBiZWNhdXNlIHdlIG5lZWQgdG8gZGVmaW5pdGVseSBrbm93IHdoZW4gdG8gZXhwZWN0IGEgXCJzdGFydFwiIGV2ZW50LlxuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBxdWV1ZSwgdGhlIFwic3RhcnRcIiBldmVudCBjb3VsZCBiZSBoYXBwZW5pbmcgbG9uZyB0aW1lIGxhdGVyIGJlY2F1c2UgaXQncyBzdGlsbCBwZW5kaW5nIGluIHRoZSBxdWV1ZS5cblxuICAgIC8vIEJ1dCB3aXRoIHRoZSBjdXN0b20gcXVldWUsIHRoZSBmaXJzdCBpdGVtIG1pZ2h0IGJlIHN0YXJ0ZWQgZnJvbSBub24tdXNlciBldmVudC4gVGhhdCBtZWFucyBpbiBTYWZhcmksIHRoZSBmaXJzdCBpdGVtIGlzIG11dGVkLlxuICAgIC8vIEFuZCBhZnRlciB0aGUgZmlyc3QgZmFpbCwgdGhlIGN1c3RvbSBxdWV1ZSB3aWxsIHBsYXkgdGhlIHNlY29uZCBpdGVtIGZyb20gYSBub24tdXNlciBldmVudCBjb2RlIHBhdGguIFRoYXQgbWVhbnMsIGFsbCBzdWJzZXF1ZW50XG4gICAgLy8gaXRlbXMgYXJlIGJsb2NrZWQgdW50aWwgU2FmYXJpIGhhcyB0aGUgdmVyeSBmaXJzdCBpdGVtIHF1ZXVlZCBmcm9tIHVzZXIgZXZlbnQuXG5cbiAgICAvLyBjb25zb2xlLmRlYnVnKGBTVEFSVElORzogJHsgdXR0ZXJhbmNlLnRleHQgfWApO1xuXG4gICAgdGhpcy5zcGVha2luZyA9IHRydWU7XG5cbiAgICBhd2FpdCByZXRyeShhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5jZWxsZWQnKTtcbiAgICAgIH1cblxuICAgICAgc3BlZWNoU3ludGhlc2lzLnNwZWFrKHV0dGVyYW5jZSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgc3RhcnREZWZlcnJlZC5wcm9taXNlLFxuICAgICAgICAgIHRpbWVvdXQoMTAwMClcbiAgICAgICAgXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBUaGlzIGlzIHJlcXVpcmVkIGZvciBDaHJvbWUgcXVpcmtzLlxuICAgICAgICAvLyBDaHJvbWUgZG9lc24ndCBrbm93IGl0IGNhbid0IHN0YXJ0IHNwZWVjaCwgYW5kIGl0IGp1c3Qgd2FpdCB0aGVyZSBmb3JldmVyLlxuICAgICAgICAvLyBXZSBuZWVkIHRvIGNhbmNlbCBpdCBvdXQuXG4gICAgICAgIHNwZWVjaFN5bnRoZXNpcy5jYW5jZWwoKTtcblxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9LCAyLCAwKTtcblxuICAgIC8vIGNvbnNvbGUuZGVidWcoYFNUQVJURUQ6ICR7IHV0dGVyYW5jZS50ZXh0IH1gKTtcblxuICAgIHV0dGVyYW5jZS5vblN0YXJ0ICYmIHV0dGVyYW5jZS5vblN0YXJ0KHsgdHlwZTogJ3N0YXJ0JyB9KTtcblxuICAgIGNvbnN0IGVuZEV2ZW50ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgIGVycm9yRGVmZXJyZWQucHJvbWlzZSxcbiAgICAgIGVuZERlZmVycmVkLnByb21pc2UsXG4gICAgICBzcGluV2FpdFVudGlsKCgpID0+ICFzcGVlY2hTeW50aGVzaXMuc3BlYWtpbmcpLnRoZW4oKCkgPT4gc2xlZXAoNTAwKSkudGhlbigoKSA9PiAoeyB0eXBlOiAnZW5kJywgYXJ0aWZpY2lhbDogdHJ1ZSB9KSlcbiAgICBdKTtcblxuICAgIC8vIGlmIChzcGVlY2hTeW50aGVzaXMuc3BlYWtpbmcpIHtcbiAgICAvLyAgIGNvbnNvbGUud2FybihgQVNTRVJUSU9OOiBzcGVlY2hTeW50aGVzaXMuc3BlYWtpbmcgc2hvdWxkIG5vdCBiZSB0cnV0aHkgYWZ0ZXIgc3BlYWsgaXMgc3RvcHBlZGApO1xuICAgIC8vIH1cblxuICAgIC8vIGNvbnNvbGUuZGVidWcoYEVOREVEOiAkeyB1dHRlcmFuY2UudGV4dCB9YCk7XG5cbiAgICB0aGlzLnNwZWFraW5nID0gZmFsc2U7XG5cbiAgICBpZiAoZW5kRXZlbnQudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgdGhyb3cgZW5kRXZlbnQuZXJyb3I7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5jZWxsZWQnKTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==